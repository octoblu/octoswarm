#!/bin/bash

script_directory(){
  local source="${BASH_SOURCE[0]}"
  local dir=""

  while [ -h "$source" ]; do # resolve $source until the file is no longer a symlink
    dir="$( cd -P "$( dirname "$source" )" && pwd )"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done

  dir="$( cd -P "$( dirname "$source" )" && pwd )"

  echo "$dir"
}

source "$(script_directory)/utils" || fatal 'unable to load utils'

debug() {
  debug_core "stack-ensure-cluster" "$@"
}

usage(){
  echo 'USAGE: stack-ensure-cluster'
  echo 'Description: bootstrap, or update, a cluster'
  echo ''
  echo 'Arguments:'
  echo '  -h, --help               print this help text'
  echo '  -v, --version            print the version'
  echo 'Environment:'
  echo '  DEBUG                    print debug output'
}

version(){
  local directory="$(script_directory)/.."

  if [ -f "$directory/VERSION" ]; then
    cat "$directory/VERSION"
  else
    echo "unknown"
  fi
}

require_config_value() {
  local key="$1"
  check_config_value "$key"
  local is_valid="$?"
  if [ "$is_valid" != "0" ]; then
    echo "* Cannot get $key from config."
    fatal "$STACK_CONFIG_PATH is invalid json."
  fi
}

check_config_value() {
  local key="$1"
  cat "$STACK_CONFIG_PATH" | jq "$key" &> /dev/null
  local is_valid="$?"
  if [ "$is_valid" != "0" ]; then
    return 1
  fi
  return 0
}

assert_required_config() {
  require_config_value '.'
  require_config_value '.stackEnvName'
  require_config_value '.stackName'
  require_config_value '.managers.count'
  require_config_value '.managers.instanceType'
  require_config_value '.workers.count'
  require_config_value '.workers.instanceType'
  require_config_value '.services[]'
}

get_config_val() {
  local key="$1"
  local value="$(cat "$STACK_CONFIG_PATH" | jq --raw-output "$key")"
  if [ -z "$value" -o "$?" != "0" ]; then
    fatal "Unable to get $key from config"
  fi
  debug "got $key = $value"
  echo "$value"
}

get_config_array() {
  local key="$1"
  cat "$STACK_CONFIG_PATH" | jq --compact-output "$key"
}

is_stack_empty() {
  if [ -d "$MACHINE_STORAGE_PATH/machines" ]; then
    return 0
  fi
  return 1
}

get_manager_elbs() {
  check_config_value ".managers.elbs[]"
  local has_elbs="$?"
  if [ "$has_elbs" == "0" ]; then
    get_config_array '.managers.elbs[]'
  fi
}

ensure_managers_elb() {
  debug 'ensuring managers elb'
  local elbs=( $(get_manager_elbs) )
  for elb in "${elbs[@]}"; do
    local elb_name="$(echo "$elb" | jq --raw-output ".")"
    elb_exists "$elb_name"
    local exists=$?
    if [ "$exists" == "1" ]; then
      debug "elb $elb_name does not exist"
      echo "ELB count insufficient, creating elb ($elb_name)..."
      say_yes || continue
      stack create-elb "$elb_name"
    else
      debug "elb $elb_name exists"
    fi
    debug "adding to elb $elb_name"
    for manager_id in $(get_manager_ids); do
      stack add-to-elb "$manager_id" "$elb_name" || fatal 'unable to add to elb'
    done
  done
}

ensure_managers() {
  debug 'ensuring managers'
  local count="$(get_managers_count)"
  local expected_count="$(get_config_val '.managers.count')"
  local ec2_instance_type="$(get_config_val '.managers.instanceType')"
  if [ "$count" -gt "$expected_count" ]; then
    debug "The current count of managers is greater than expected count"
    debug "SKIPPING..."
    return 0
  fi
  if [ "$count" == "$expected_count" ]; then
    debug "Managers count in sync with expected count"
    debug "SKIPPING..."
    return 0
  fi
  let "count_to_start = $expected_count - $count"
  debug "creating $count_to_start more managers"

  for i in $(seq 1 $count_to_start); do
    debug 'creating a manager in the background'
    let "real_count = $count + $i"
    echo "Manager count insufficient, creating manager #$real_count..."
    say_yes || continue
    stack create-manager \
      --ec2-instance-type "$ec2_instance_type" &
  done
  debug 'waiting for managers to boot'
  wait $(jobs -p)
}

ensure_workers() {
  local count="$(get_workers_count)"
  local expected_count="$(get_config_val '.workers.count')"
  local ec2_instance_type="$(get_config_val '.workers.instanceType')"

  if [ "$count" -gt "$expected_count" ]; then
    debug "The current count of workers is greater than expected count"
    debug "SKIPPING..."
    return 0
  fi

  if [ "$count" == "$expected_count" ]; then
    debug "Workers count in sync with expected count"
    debug "SKIPPING..."
    return 0
  fi

  let "count_to_start = $expected_count - $count"
  debug "creating $count_to_start more workers"

  for i in $(seq 1 $count_to_start); do
    debug "creating a worker in the background"
    let "real_count = $count + $i"
    echo "Worker count insufficient, creating worker #$real_count..."
    say_yes || continue
    stack create-worker \
      --ec2-instance-type "$ec2_instance_type" &
  done
  debug 'waiting for workers to boot'
  wait $(jobs -p)
}

ensure_services() {
  debug 'ensure services'
  local services=( $(get_config_array '.services[]') )
  for service in "${services[@]}"; do
    ensure_service "$service" || fatal "unable to ensure service"
  done
}

get_service_spec() {
  local name="$1"
  local key="$2"
  docker service inspect "$name" 2> /dev/null | jq --compact-output --raw-output ".[0].Spec${key}" 2> /dev/null
}

has_role() {
  local name="$1"
  local role="$2"
  local constraints=$(get_service_spec "$name" '.TaskTemplate.Placement.Constraints[]')
  local hasRole='false'
  for constraint in $constraints; do
    debug "constraint '$constraint'"
    if [[ "$constraint" == *'node.role'* ]]; then
      debug 'constraint exists'
      hasRole='true'
      break;
    fi
  done
  debug "has role $hasRole"
  echo "$hasRole"
}

has_docker_socket() {
  local name="$1"
  local mounts=( $(get_service_spec "$name" '.TaskTemplate.ContainerSpec.Mounts[]') )
  local hasDockerSocket='false'
  local dockerSock='/var/run/docker.sock'
  for mount in $mounts; do
    debug 'mount' $mount
    local mountType="$(echo "$mount" | jq --compact-output -r '.Type')"
    local mountSource="$(echo "$mount" | jq --compact-output -r '.Source')"
    local mountTarget="$(echo "$mount" | jq --compact-output -r '.Target')"
    if [ "$mountType" != "bind" ]; then
      continue
    fi
    if [ "$mountSource" != "$dockerSock" ]; then
      continue
    fi
    if [ "$mountTarget" != "$dockerSock" ]; then
      continue
    fi
    hasDockerSocket='true'
    break;
  done
  debug "has docker socket $hasDockerSocket"
  echo "$hasDockerSocket"
}

has_same_docker_image() {
  local name="$1"
  local expected_image="$2"
  local image="$(get_service_spec "$name" '.TaskTemplate.ContainerSpec.Image')"
  if [ "$image" == "$expected_image" ]; then
    echo 'true'
  else
    echo 'false'
  fi
}

has_same_replicas() {
  local name="$1"
  local expected_count="$2"
  local count="$(get_service_spec "$name" '.Mode.Replicated.Replicas')"
  if [ "$count" == "$expected_count" ]; then
    echo 'true'
  else
    echo 'false'
  fi
}

ensure_network() {
  local name="$1"
  docker network inspect "$name" &> /dev/null
  if [ "$?" != "0" ]; then
    debug "creating network $name"
    docker network create --driver overlay "$name"
    sleep 1
  fi
}

run_service_command() {
  local service="$1"
  local opt_beekeeper
  local opt_docker_sock
  local opt_role
  local opt_publish
  local opt_traefik
  local opt_run
  local opt_env
  local opt_with_registry_auth
  local opt_mode
  local opt_replicas
  local name="$(echo "$service" | jq -r '.name')"
  local count="$(echo "$service" | jq -r '.count')"
  local docker_repo="$(echo "$service" | jq -r '.docker.repo')"
  local network="$(echo "$service" | jq -r '.docker.network')"
  local mode="$(echo "$service" | jq -r '.docker.mode')"
  local image="$(echo "$service" | jq -r '.docker.image')"
  local role="$(echo "$service" | jq -r '.docker.role')"
  local dockerSock="$(echo "$service" | jq -r '.docker.sock')"
  local publish="$(echo "$service" | jq --compact-output -r '.docker.publish[]' 2>/dev/null)"
  local traefikHost="$(echo "$service" | jq -r '.traefik.host')"
  local traefikPathPrefix="$(echo "$service" | jq -r '.traefik.pathPrefix')"
  local runOptions="$(echo "$service" | jq --compact-output -r '.docker.runOptions[]' 2>/dev/null)"
  local withRegistryAuth="$(echo "$service" | jq -r '.docker.withRegistryAuth')"
  local labelFlag='--label'
  local mountFlag='--mount'
  local publishFlag='--publish'
  local constraintFlag='--constraint'
  local envFlag='--env'
  local isUpdate='false'
  if [ "$(get_service_spec "$name")" != "null" ]; then
    isUpdate='true'
    labelFlag='--label-add'
    mountFlag='--mount-add'
    publishFlag='--publish-add'
    constraintFlag='--constraint-add'
    envFlag='--env-add'
  fi
  if [ "$network" == "null" ]; then
    network="traefik"
  fi
  if [ "$mode" == "null" ]; then
    mode="replicated"
  fi
  if [ "$mode" == "replicated" ]; then
    if [ "$(has_same_replicas "$name" "$count")" == 'false' ]; then
      opt_replicas="--replicas $count"
    fi
  fi
  opt_mode="--mode $mode"
  if [ "$image" == "null" ]; then
    if [ "$docker_repo" == "null" ]; then
      image="$(swarm-get-latest-docker-url "octoblu/$name")"
    else
      image="$(swarm-get-latest-docker-url "$docker_repo")"
    fi
  fi
  local beekeeper="$(echo "$service" | jq -r '.beekeeper')"
  if [ "$beekeeper" == "null" ]; then
    beekeeper="true"
  fi
  if [ "$beekeeper" == "true" ]; then
    opt_beekeeper="$labelFlag octoblu.beekeeper.update=true"
  fi
  if [ "$beekeeper" == "false" ]; then
    opt_beekeeper="$labelFlag octoblu.beekeeper.update=false"
  fi
  if [ "$withRegistryAuth" == "true" ]; then
    opt_with_registry_auth="--with-registry-auth"
  fi
  if [ "$dockerSock" == "true" ]; then
    if [ "$(has_docker_socket "$name")" != 'true' ]; then
      opt_docker_sock="$mountFlag type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock"
    fi
  fi
  if [ "$role" != "null" ]; then
    if [ "$(has_role "$name" "$role")" != 'true' ]; then
      opt_role="$constraintFlag node.role==$role"
    fi
  fi
  if [ "$traefikHost" != "null" ]; then
    local frontendRule="Host:$traefikHost"
    if [ "$traefikPathPrefix" != "null" ]; then
      frontendRule="${frontendRule};PathPrefix:${traefikPathPrefix}"
    fi
    opt_traefik="$labelFlag traefik.frontend.rule=${frontendRule} $labelFlag traefik.port=80 $labelFlag traefik.docker.network=traefik"
  fi
  local env_folder="$STACK_ENV_DIR/$name"
  if [ -d "$env_folder" ]; then
    for file in $(ls $env_folder); do
      value="$(cat "$env_folder/$file")"
      opt_env="$opt_env $envFlag $file=$value "
    done
  fi

  for port in $publish; do
    opt_publish="$opt_publish $publishFlag $port"
  done

  for option in $runOptions; do
    opt_run="$opt_run $option"
  done

  ensure_network "$network"

  if [ "$isUpdate" == "true" ]; then
    debug 'updating service'
    local opt_image
    if [ "$(has_same_docker_image "$name" "$image")" != 'true' ]; then
      opt_image="--image $image"
    fi
    docker service update \
      $opt_replicas \
      $opt_docker_sock \
      $opt_role \
      $opt_traefik \
      $opt_beekeeper \
      $opt_with_registry_auth \
      $opt_image \
      $opt_env \
      "$name"
  else
    debug 'creating service'
    docker service create \
      --name "$name" \
      --network "$network" \
      $opt_mode \
      $opt_replicas \
      $opt_publish \
      $opt_docker_sock \
      $opt_role \
      $opt_traefik \
      $opt_beekeeper \
      $opt_with_registry_auth \
      $opt_env \
      "$image" \
        $opt_run
  fi
}

ensure_service() {
  local service="$1"
  local name="$(echo "$service" | jq -r '.name')"
  local count="$(echo "$service" | jq -r '.count')"
  run_service_command "$service"
  return $?
}

main() {
  while [ "$1" != "" ]; do
    local param="$1"
    local value="$2"

    case "$param" in
      -h | --help)
        usage
        exit 0
        ;;
      -v | --version)
        version
        exit 0
        ;;
      *)
        if [ "${param::1}" == '-' ]; then
          echo "ERROR: unknown parameter \"$param\""
          usage
          exit 1
        fi
        ;;
    esac
    shift
  done

  assert_required_config

  is_stack_empty || fatal 'Not initialized, run `create-cluster`'

  ensure_managers || fatal 'unable to ensure managers'
  ensure_managers_elb || fatal 'unable to ensure managers elb'
  ensure_workers || fatal 'unable to ensure workers'
  ensure_services || fatal 'unable to ensure services'
}

main "$@"
