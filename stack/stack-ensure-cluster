#!/bin/bash

script_directory(){
  local source="${BASH_SOURCE[0]}"
  local dir=""

  while [ -h "$source" ]; do # resolve $source until the file is no longer a symlink
    dir="$( cd -P "$( dirname "$source" )" && pwd )"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done

  dir="$( cd -P "$( dirname "$source" )" && pwd )"

  echo "$dir"
}

source "$(script_directory)/utils" || fatal 'unable to load utils'

debug() {
  debug_core "stack-ensure-cluster" "$@"
}

usage(){
  echo 'USAGE: stack-ensure-cluster [/path/to/cluster.json]'
  echo 'Description: bootstrap, or update, a cluster'
  echo ''
  echo 'Arguments:'
  echo '  -h, --help               print this help text'
  echo '  -v, --version            print the version'
  echo 'Environment:'
  echo '  DEBUG                    print debug output'
}

version(){
  local directory="$(script_directory)"

  if [ -f "$directory/VERSION" ]; then
    cat "$directory/VERSION"
  else
    echo "unknown"
  fi
}

assert_required_params(){
  local config_path="$1"

  if [ -n "$config_path" -a -f "$config_path"  ]; then
    return 0
  fi

  usage

  if [ -z "$config_path" ]; then
    echo "config_path is missing"
  fi

  if [ ! -f "$config_path" ]; then
    echo "$config_path is not a file"
  fi

  exit 1
}

require_config_value() {
  local key="$1"
  check_config_value "$key"
  local is_valid="$?"
  if [ "$is_valid" != "0" ]; then
    echo "* Cannot get $key from config."
    fatal "$STACK_CONFIG_PATH is invalid json."
  fi
}

check_config_value() {
  local key="$1"
  cat "$STACK_CONFIG_PATH" | jq "$key" &> /dev/null
  local is_valid="$?"
  if [ "$is_valid" != "0" ]; then
    return 1
  fi
  return 0
}

assert_required_config() {
  require_config_value '.'
  require_config_value '.stackEnvName'
  require_config_value '.stackName'
  require_config_value '.managers.count'
  require_config_value '.managers.instanceType'
  require_config_value '.workers.count'
  require_config_value '.workers.instanceType'
  require_config_value '.services[]'
}

get_config_val() {
  local key="$1"
  local value="$(cat "$STACK_CONFIG_PATH" | jq --raw-output "$key")"
  if [ -z "$value" -o "$?" != "0" ]; then
    fatal "Unable to get $key from config"
  fi
  debug "got $key = $value"
  echo "$value"
}

get_config_array() {
  local key="$1"
  cat "$STACK_CONFIG_PATH" | jq --compact-output "$key"
}

is_stack_empty() {
  local stack_env_name="$(get_config_val '.stackEnvName')"
  local stack_name="$(get_config_val '.stackName')"
  local swarm_env_dir="$HOME/Projects/Octoblu/swarm-$stack_env_name"
  local stack_env_dir="$swarm_env_dir/stacks/$stack_name/machine-template"
  debug "stack_env_dir $stack_env_dir"
  if [ -d "$stack_env_dir" ]; then
    return 0
  fi
  return 1
}

get_manager_elbs() {
  check_config_value ".managers.elbs[]"
  local has_elbs="$?"
  if [ "$has_elbs" == "0" ]; then
    get_config_array '.managers.elbs[]'
  fi
}

create_stack(){
  debug 'about to create stack'
  local stack_env_name="$(get_config_val '.stackEnvName')"
  local stack_name="$(get_config_val '.stackName')"
  local ec2_instance_type="$(get_config_val '.managers.instanceType')"
  local elbs=( $(get_manager_elbs) )
  local skip_elb_flag

  if [ ${#elbs[@]} -eq 0 ]; then
    skip_elb_flag='--skip-elb'
  fi

  echo "Stack doesn't exist, we are going to create the first manager..."
  say_yes || fatal 'Exiting due to human fear.'

  env OCTOSWARM_INIT_CMD='stack ensure-cluster' \
    "$(script_directory)/stack-initialize" "$stack_env_name" "$stack_name" \
    --ec2-instance-type "$ec2_instance_type" $skip_elb_flag || fatal 'Unable to initialize stack'
  exit 0
}

ensure_managers_elb() {
  debug 'ensuring managers elb'
  local stack_env_name="$(get_config_val '.stackEnvName')"
  local stack_name="$(get_config_val '.stackName')"
  local elbs=( $(get_manager_elbs) )
  for elb in "${elbs[@]}"; do
    local elb_name="$(echo "$elb" | jq --raw-output ".")"
    elb_exists "$elb_name"
    local exists=$?
    if [ "$exists" == "1" ]; then
      debug "elb $elb_name does not exist"
      echo "ELB count insufficient, creating elb ($elb_name)..."
      say_yes || continue
      "$(script_directory)/stack-create-elb" "$elb_name"
    else
      debug "elb $elb_name exists"
    fi
    debug "adding to elb $elb_name"
    for manager_id in $(get_manager_ids); do
      "$(script_directory)/stack-add-to-elb" "$manager_id" "$elb_name" || fatal 'unable to add to elb'
    done
  done
}

ensure_managers() {
  debug 'ensuring managers'
  local count="$(get_managers_count)"
  local expected_count="$(get_config_val '.managers.count')"
  local ec2_instance_type="$(get_config_val '.managers.instanceType')"
  local elbs=( $(get_manager_elbs) )
  local skip_elb_flag

  if [ ${#elbs[@]} -eq 0 ]; then
    skip_elb_flag='--skip-elb'
  fi

  if [ "$count" -gt "$expected_count" ]; then
    debug "The current count of managers is greater than expected count"
    debug "SKIPPING..."
    return 0
  fi
  if [ "$count" == "$expected_count" ]; then
    debug "Managers count in sync with expected count"
    debug "SKIPPING..."
    return 0
  fi
  let "count_to_start = $expected_count - $count"
  debug "creating $count_to_start more managers"

  for i in $(seq 1 $count_to_start); do
    debug 'creating a manager in the background'
    let "real_count = $count + $i"
    echo "Manager count insufficient, creating manager #$real_count..."
    say_yes || continue
    "$(script_directory)/stack-create-manager" \
      --ec2-instance-type "$ec2_instance_type" $skip_elb_flag &
  done
  debug 'waiting for managers to boot'
  wait $(jobs -p)
}

ensure_workers() {
  local count="$(get_workers_count)"
  local expected_count="$(get_config_val '.workers.count')"
  local ec2_instance_type="$(get_config_val '.workers.instanceType')"

  if [ "$count" -gt "$expected_count" ]; then
    debug "The current count of workers is greater than expected count"
    debug "SKIPPING..."
    return 0
  fi

  if [ "$count" == "$expected_count" ]; then
    debug "Workers count in sync with expected count"
    debug "SKIPPING..."
    return 0
  fi

  let "count_to_start = $expected_count - $count"
  debug "creating $count_to_start more workers"

  for i in $(seq 1 $count_to_start); do
    debug "creating a worker in the background"
    let "real_count = $count + $i"
    echo "Worker count insufficient, creating worker #$real_count..."
    say_yes || continue
    "$(script_directory)/stack-create-worker" \
      --ec2-instance-type "$ec2_instance_type" &
  done
  debug 'waiting for workers to boot'
  wait $(jobs -p)
}

ensure_services() {
  debug 'ensure services'
  local services=( $(get_config_array '.services[]') )
  for service in "${services[@]}"; do
    ensure_service "$service" || fatal "unable to ensure service"
  done
}

get_service_spec() {
  local name="$1"
  docker service inspect "$name" | jq --compact-output -r '.[0].Spec' 2> /dev/null
}

has_constraint() {
  local name="$1"
  local expected_constraint="$2"
  local constraints="$(get_service_spec "$name" | jq --compact-output -r '.TaskTemplate.Placement.Constraints[]')"
  local addConstraint='true'
  for constraint in $constraints; do
    debug "$constraint == $expected_constraint"
    if [ "$constraint" == "$expected_constraint" ]; then
      debug 'constraint exists'
      addConstraint='false'
    fi
  done
  debug "add constraint $addConstraint"
  echo "$addConstraint"
}

has_docker_socket() {
  local name="$1"
  local mounts="$(get_service_spec "$name" | jq --compact-output -r '.TaskTemplate.ContainerSpec.Mounts[]')"
  local addMount='true'
  local dockerSock='/var/run/docker.sock'
  for mount in $mounts; do
    local mountType="$(echo "$mount" | jq --compact-output -r '.Type')"
    local mountSource="$(echo "$mount" | jq --compact-output -r '.Source')"
    local mountTarget="$(echo "$mount" | jq --compact-output -r '.Target')"
    debug "got mount $mount"
    if [ "$mountType" != "bind" ]; then
      continue
    fi
    if [ "$mountSource" != "$dockerSock" ]; then
      continue
    fi
    if [ "$mountTarget" != "$dockerSock" ]; then
      continue
    fi
    addMount='false'
  done
  debug "add mount $addMount"
  echo "$addMount"
}

has_same_replicas() {
  local name="$1"
  local expected_count="$2"
  local count="$(get_service_spec "$name" | jq -r '.Mode.Replicated.Replicas')"
  local hasSame='false'
  if [ "$count" == "$expected_count" ]; then
    hasSame='true'
  fi
  debug "has same replicas $hasSame"
  echo "$hasSame"
}

get_service_command() {
  local command="$1"
  local service="$2"
  local opt_beekeeper
  local opt_docker_sock
  local opt_role
  local opt_publish
  local opt_traefik
  local opt_run
  local opt_env
  local opt_with_registry_auth
  local opt_mode
  local opt_replicas
  local name="$(echo "$service" | jq -r '.name')"
  local count="$(echo "$service" | jq -r '.count')"
  local docker_repo="$(echo "$service" | jq -r '.docker.repo')"
  local network="$(echo "$service" | jq -r '.docker.network')"
  local mode="$(echo "$service" | jq -r '.docker.mode')"
  local image="$(echo "$service" | jq -r '.docker.image')"
  local role="$(echo "$service" | jq -r '.docker.role')"
  local dockerSock="$(echo "$service" | jq -r '.docker.sock')"
  local publish="$(echo "$service" | jq --compact-output -r '.docker.publish[]' 2>/dev/null)"
  local traefikHost="$(echo "$service" | jq -r '.traefik.host')"
  local traefikPathPrefix="$(echo "$service" | jq -r '.traefik.pathPrefix')"
  local runOptions="$(echo "$service" | jq --compact-output -r '.docker.runOptions[]' 2>/dev/null)"
  local withRegistryAuth="$(echo "$service" | jq -r '.docker.withRegistryAuth')"
  local labelFlag='--label'
  local mountFlag='--mount'
  local publishFlag='--publish'
  local constraintFlag='--constraint'
  if [ "$command" == 'update' ]; then
    labelFlag='--label-add'
    mountFlag='--mount-add'
    publishFlag='--publish-add'
    constraintFlag='--constraint-add'
  fi
  if [ "$network" == "null" ]; then
    network="traefik"
  fi
  if [ "$mode" == "null" ]; then
    mode="replicated"
  fi
  if [ "$mode" == "replicated" ]; then
    if [ "$(has_same_replicas "$name" "$count")" == 'false' ]; then 
      opt_replicas="--replicas $count"
    fi
  fi
  opt_mode="--mode $mode"
  if [ "$image" == "null" ]; then
    if [ "$docker_repo" == "null" ]; then
      image="$(swarm-get-latest-docker-url "octoblu/$name")"
    else
      image="$(swarm-get-latest-docker-url "$docker_repo")"
    fi
  fi
  local beekeeper="$(echo "$service" | jq -r '.beekeeper')"
  if [ "$beekeeper" == "null" ]; then
    beekeeper="true"
  fi
  if [ "$beekeeper" == "true" ]; then
    opt_beekeeper="$labelFlag octoblu.beekeeper.update=true"
  fi
  if [ "$withRegistryAuth" == "true" ]; then
    opt_with_registry_auth="--with-registry-auth"
  fi
  if [ "$dockerSock" == "true" ]; then
    if [ "$(has_docker_socket "$name")" == 'true' ]; then
      opt_docker_sock="$mountFlag type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock"
    fi
  fi
  if [ "$role" != "null" ]; then
    if [ "$(has_constraint "$name" "node.role==$role")" == 'true' ]; then
      opt_role="$constraintFlag node.role==$role"
    fi
  fi
  if [ "$traefikHost" != "null" ]; then
    local frontendRule="Host:$traefikHost"
    if [ "$traefikPathPrefix" != "null" ]; then
      frontendRule="${frontendRule};PathPrefix:${traefikPathPrefix}"
    fi
    opt_traefik="$labelFlag traefik.frontend.rule=${frontendRule} $labelFlag traefik.port=80 $labelFlag traefik.docker.network=traefik"
  fi
  for port in $publish; do
    opt_publish="$opt_publish $publishFlag $port"
  done
  for option in $runOptions; do
    opt_run="$opt_run $option"
  done
  docker network inspect "$network" &> /dev/null
  if [ "$?" != "0" ]; then
    debug "creating network $network"
    docker network create --driver overlay "$network"
  fi
  opt_env="$(docker-service-get-env-args "$name")"
  local run_command
  if [ "$command" == "update" ]; then
    debug 'updating service'
    echo docker service update \
      $opt_replicas \
      $opt_publish \
      $opt_docker_sock \
      $opt_role \
      $opt_traefik \
      $opt_beekeeper \
      $opt_with_registry_auth \
      --image "$image" \
      "$name"
  elif [ "$command" == "create" ]; then
    debug 'creating service'
    echo docker service create \
      --name "$name" \
      --network "$network" \
      $opt_mode \
      $opt_replicas \
      $opt_publish \
      $opt_docker_sock \
      $opt_role \
      $opt_traefik \
      $opt_beekeeper \
      $opt_with_registry_auth \
      $opt_env \
      "$image" \
        $opt_run
  else
    fatal 'Service can only be updated, or created'
  fi
}

run_service_command() {
  local cmd="$@"
  echo "We are about to run:"
  echo "   $cmd"
  say_yes || return 0
  $cmd
}

ensure_service() {
  local service="$1"
  local name="$(echo "$service" | jq -r '.name')"
  local count="$(echo "$service" | jq -r '.count')"
  debug "ensure service $name - $count - $skip_env_add"
  service_exists "$name"
  if [ "$?" == "0" ]; then
    debug 'service update'
    local command="$(get_service_command 'update' "$service")"
    run_service_command $command
  else
    debug 'create service'
    local command="$(get_service_command 'create' "$service")"
    run_service_command $command
  fi
  return $?
}

main() {
  local config_path
  while [ "$1" != "" ]; do
    local param="$1"
    local value="$2"

    case "$param" in
      -h | --help)
        usage
        exit 0
        ;;
      -v | --version)
        version
        exit 0
        ;;
      *)
        if [ "${param::1}" == '-' ]; then
          echo "ERROR: unknown parameter \"$param\""
          usage
          exit 1
        fi
        if [ -z "$config_path" ]; then
          config_path="$param"
        fi
        ;;
    esac
    shift
  done

  if [ ! -d "$config_path" ]; then
    config_path="$STACK_ENV_DIR/cluster.json"
  fi

  if [ ! -d "$config_path" ]; then
    config_path="$PWD/cluster.json"
  fi

  assert_required_params "$config_path"

  unset STACK_CONFIG_PATH
  export STACK_CONFIG_PATH="$config_path"
  debug "config file $STACK_CONFIG_PATH"

  assert_required_config

  is_stack_empty || create_stack

  ensure_managers || fatal 'unable to ensure managers'
  ensure_managers_elb || fatal 'unable to ensure managers elb'
  ensure_workers || fatal 'unable to ensure workers'
  ensure_services || fatal 'unable to ensure services'

  unset STACK_CONFIG_PATH
}

main "$@"
