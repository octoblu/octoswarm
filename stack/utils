#!/bin/bash

set_ulimit() {
  sudo sysctl -w kern.ipc.somaxconn=4096
  sudo sysctl -w kern.maxfiles=12288
  sudo sysctl -w kern.maxfilesperproc=10240
  ulimit -n 10240
}

say_yes() {
  local response
  if [ "$SAY_YES" == 'false' ]; then
    echo "You've choosen to not just always say yes. So we are not just gonna do it."
    read -s -p "press 'y' if you want to continue."$'\n' -n 1 response
    if [[ "$response" == 'y' ]]; then
      echo 'Good choice...'
      return 0
    fi
    echo 'Fine. Skipping...'
    return 1
  fi

  return 0
}

confirm_please() {
  local response
  read -s -p "press 'y' if you want to continue."$'\n' -n 1 response
  if [[ "$response" != 'y' ]]; then
    exit 1
  fi
}

debug_core() {
  local debug_key="$1"; shift
  local cyan='\033[0;36m'
  local no_color='\033[0;0m'
  if [ -z "$DEBUG" ]; then
    return 0
  fi
  echo "$debug_key" | grep "$DEBUG"
  local is_valid_debug="$?"
  if [ "$debug_key" == '*' -a "$is_valid_debug" != "0" ]; then
    return 0
  fi
  local message="$@"
  errecho "[${cyan}${debug_key}${no_color}]: $message"
}

debug() {
  debug_core "$SCRIPT_NAME" "$@"
}

fatal() {
  local message="$@"
  errecho "Error: $message"
  exit 1
}

warn() {
  local message="$@"
  errecho "Warning: $message"
}

errecho() {
  local message="$@"
  (>&2 echo -e "$message")
}

get_machines() {
  docker-machine ls | grep -v ACTIVE
}

get_machine_names() {
  get_machines | awk '{print $1}'
}

get_nodes_by_role_unverified() {
  local role="$1"
  docker node ls --filter "role = $role" | grep Ready | grep -v HOSTNAME | sed 's/\*//' | awk '{print $2}'
}

get_nodes_by_role() {
  local role="$1"
  if [ -z "$STACK_DIR" ]; then
    debug 'cannot get nodes because it does not have STACK_DIR set'
    return 0
  fi
  for node_name in $(get_nodes_by_role_unverified "$role"); do
    verify_node_name "$node_name"
  done
}

verify_node_name() {
  local node_name="$1"
  if [ "$node_name" == "null" ]; then
    fatal "Unable to find a matching machine. Try and octoswarm in again."
  elif [ "$node_name" == "moby" ]; then
    fatal "Found a matching machine, but it is likely your local machine (moby). Try and octoswarm in again."
  else
    echo "$node_name"
  fi
}

get_managers() {
  get_nodes_by_role 'manager'
}

get_manager_ids() {
  get_managers
}

get_managers_count() {
  get_managers | wc -l | xargs
}

get_manager_id_unverified() {
  docker node ls --filter "role = manager" | grep -v HOSTNAME | grep '*' | sed 's/\*//' | awk '{print $2}'
}

get_manager_id() {
  local manager_id
  if [ -z "$STACK_DIR" ]; then
    debug 'cannot get manager id because it does not have STACK_DIR set'
    return 0
  fi
  manager_id="$(get_manager_id_unverified)"
  verify_node_name "$manager_id"
}

get_manager_public_ip() {
  docker-machine ip "$(get_manager_id)"
}

get_manager_private_ip() {
  local public_ip
  public_ip="$(get_manager_public_ip)"
  aws ec2 describe-instances --filters "Name=ip-address,Values=$public_ip" | jq --raw-output  '.Reservations[].Instances[].PrivateIpAddress'
}

get_workers() {
  get_nodes_by_role 'worker'
}

get_workers_count() {
  get_workers | wc -l | xargs
}

service_exists() {
  local name="$1"
  for service_name in $(docker service ls | grep -v NAME | awk '{print $2}'); do
    if [ "$service_name" == "$name" ]; then
      return 0
    fi
  done
  return 1
}

elb_exists() {
  local elb_name="$1"
  aws elb describe-load-balancers --load-balancer-name "$elb_name" &> /dev/null || return 1
  return 0
}

require_config_value() {
  local key="$1"
  check_config_value "$key"
  local is_valid="$?"
  if [ "$is_valid" != "0" ]; then
    echo "* Cannot get $key from config."
    fatal "$STACK_CONFIG_PATH is invalid json."
  fi
}

check_config_value() {
  local key="$1"
  cat "$STACK_CONFIG_PATH" | jq "$key" &> /dev/null
  local is_valid="$?"
  if [ "$is_valid" != "0" ]; then
    return 1
  fi
  return 0
}

get_config_val() {
  local key="$1"
  local value
  value="$(cat "$STACK_CONFIG_PATH" | jq --raw-output "$key")"
  if [ -z "$value" -o "$?" != "0" ]; then
    fatal "Unable to get $key from config"
  fi
  debug "got $key = $value"
  echo "$value"
}

get_service_val() {
  local service="$1"
  local key="$2"
  value="$(echo "$service" | jq --raw-output "$key")"
  if [ "$?" != "0" ]; then
    fatal "Unable to get $key from config"
  fi
  if [ "$value" == "null" ]; then
    value=""
  fi
  debug "got $key = $value"
  echo "$value"
}

get_config_array() {
  local key="$1"
  cat "$STACK_CONFIG_PATH" | jq --compact-output "$key"
}

get_service_full_name() {
  local service="$1"
  local name="$(get_service_val "$service" '.name')"
  local stack_env_name="$(get_config_val '.stackEnvName')"
  local stack_name="$(get_config_val '.stackName')"

  echo "$stack_env_name-$stack_name-$name"
}

is_stack_empty() {
  if [ -d "$MACHINE_STORAGE_PATH/machines" ]; then
    return 0
  fi
  return 1
}

version(){
  if [ -f "$VERSION_FILE_PATH" ]; then
    cat "$VERSION_FILE_PATH"
  else
    echo "unknown"
  fi
}

run_cmd() {
  if [ "$DRY_RUN" == 'true' ]; then
    echo "$@"
  else
    "$@"
  fi
}

script_directory(){
  local source="${BASH_SOURCE[0]}"
  local dir=""

  while [ -h "$source" ]; do # resolve $source until the file is no longer a symlink
    dir="$( cd -P "$( dirname "$source" )" && pwd )"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done

  dir="$( cd -P "$( dirname "$source" )" && pwd )"

  echo "$dir"
}
