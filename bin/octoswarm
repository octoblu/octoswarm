#!/bin/bash

assert_required_tools(){
  if [ "$(which envsubst)" == "" ]; then echo "Missing 'envsubst' utility. 'brew install gettext; brew link gettext --force' to install."
    exit 1
  fi
}

assert_required_params(){
  local stack_env_name="$1"

  if [ -n "$stack_env_name" -a -n "$stack_name"  ]; then
    return 0
  fi

  usage

  if [ -z "$stack_env_name" ]; then
    echo "stack_env_name is missing"
  fi

  if [ -z "$stack_name" ]; then
    echo "stack_name is missing"
  fi

  exit 1
}

get_manager_machine_id(){
  local stack_env_name="$1"
  local stack_name="$2"
  if [ ! -d "$HOME/Projects/Octoblu/swarm-$stack_env_name/stacks/$stack_name" ]; then
    return 1
  fi
  local dir="$HOME/Projects/Octoblu/swarm-$stack_env_name/stacks/$stack_name/machine/machines"

  local random_dir="$(find "$dir" -iname '*manager-*' -maxdepth 1 -mindepth 1 -type d -print0 | gsort --zero-terminated --random-sort | head -1)"
  echo $(basename "$random_dir")
}

script_directory(){
  local source="${BASH_SOURCE[0]}"
  local dir=""

  while [ -h "$source" ]; do # resolve $source until the file is no longer a symlink
    dir="$( cd -P "$( dirname "$source" )" && pwd )"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done

  dir="$( cd -P "$( dirname "$source" )" && pwd )"

  echo "$dir"
}

setup_session() {
  local session="$1"
  local machine_id="$2"
  eval $(docker-machine env --shell=bash "$machine_id")
  tmux set-environment -t $session DOCKER_CERT_PATH $DOCKER_CERT_PATH
  tmux set-environment -t $session DOCKER_TLS_VERIFY $DOCKER_TLS_VERIFY
  tmux set-environment -t $session DOCKER_HOST $DOCKER_HOST
  tmux set-environment -t $session DOCKER_MACHINE_NAME $DOCKER_MACHINE_NAME
  eval $(docker-machine env --unset)
}

select_tab() {
  local session="$1"
  local tab="$2"
  tmux select-window -t "${session}:${tab}"
}

setup_tab_zero() {
  local session="$1"
  tmux send-keys -t "${session}:0.0" C-m || return 1
  tmux send-keys -t "${session}:0.0" "tmux kill-session -t ${session}" || return 1
}

setup_tab_shell() {
  local session="$1"
  tmux new-window -t "${session}:1" -n "shell" || return 1
}

assert_machine_id() {
  local machine_id="$1"
  local stack_env_name="$2"
  if [ -z "$machine_id" ]; then
    echo 'Error: Unable to get machine id, this stack may not exist'
    echo ''
    echo 'It can be one of the following:'
    echo ''
    ls "$HOME/Projects/Octoblu/swarm-$stack_env_name/stacks"
    echo ''
    echo 'If you are trying to create a new cluster, try running octoswarm-init'
    echo ''
    exit 1
  fi
}

setup_machine_storage_path() {
  local stack_env_name="$1"
  local stack_name="$2"

  local raw_machine_storage_path="$HOME/Projects/Octoblu/swarm-$stack_env_name/stacks/$stack_name/machine-template"
  local machine_storage_path="$HOME/Projects/Octoblu/swarm-$stack_env_name/stacks/$stack_name/machine"

  if [ ! -d "$raw_machine_storage_path" ]; then
    echo "Missing stack machine-template"
    exit 1
  fi

  mkdir -p $machine_storage_path
  cp -rfp $raw_machine_storage_path/* $MACHINE_STORAGE_PATH

  export RAW_MACHINE_STORAGE_PATH="$raw_machine_storage_path"
  export MACHINE_STORAGE_PATH="$machine_storage_path"

  tmux set-environment -t $session MACHINE_STORAGE_PATH "$machine_storage_path"
}

setup_docker_machine() {
  local session="$1"
  local stack_env_name="$2"
  local stack_name="$3"

  if [ "$stack_env_name" != "dev" ]; then
    setup_machine_storage_path "$stack_env_name" "$stack_name" || fatal 'unable to setup up machine storage path'
  fi
}

start_server() {
  tmux start-server
}

attach_session() {
  local session="$1"
  tmux attach-session -t "$session"
}

create_session() {
  local session="$1"
  local stack_env_name="$2"
  local stack_name="$3"
  export SWARM_ENV_DIR="$HOME/Projects/Octoblu/swarm-$stack_env_name"
  export STACK_ENV_DIR="$SWARM_ENV_DIR/stacks/$stack_name"
  export STACK_NAME="$stack_env_name-$stack_name"
  export SWARM_NAME="$stack_env_name"

  cd "$STACK_ENV_DIR"
  tmux new-session -s "$session" -c "$STACK_ENV_DIR" -n √ø -d
  tmux set-environment -t $session SWARM_ENV_DIR $SWARM_ENV_DIR
  tmux set-environment -t $session STACK_ENV_DIR $STACK_ENV_DIR
  tmux set-environment -t $session STACK_NAME $STACK_NAME
  tmux set-environment -t $session SWARM_NAME $SWARM_NAME
}

has_session() {
  local session="$1"
  tmux has-session -t "$session"
}

fatal() {
  local message="$1"
  echo "Error: $message"
  exit 1
}

script_directory(){
  local source="${BASH_SOURCE[0]}"
  local dir=""

  while [ -h "$source" ]; do # resolve $source until the file is no longer a symlink
    dir="$( cd -P "$( dirname "$source" )" && pwd )"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done

  dir="$( cd -P "$( dirname "$source" )" && pwd )"

  echo "$dir"
}

usage(){
  echo 'USAGE: octoswarm <docker-machine-env> <stack-name>'
  echo 'Description: join a octoswarm tmux session'
  echo ''
  echo 'Arguments:'
  echo '  -h, --help         print this help text'
  echo '  -v, --version      print the version'
  echo ''
}

version(){
  local directory="$(script_directory)"

  if [ -f "$directory/VERSION" ]; then
    cat "$directory/VERSION"
  else
    echo "unknown"
  fi
}

main() {
  local stack_env_name
  local stack_name
  while [ "$1" != "" ]; do
    local param="$1"
    local value="$2"
    case "$param" in
      -h | --help)
        usage
        exit 0
        ;;
      -v | --version)
        version
        exit 0
        ;;
      *)
        if [ "${param::1}" == '-' ]; then
          echo "ERROR: unknown parameter \"$param\""
          usage
          exit 1
        fi
        if [ -z "$stack_env_name" ]; then
          stack_env_name="$param"
        elif [ -z "$stack_name" ]; then
          stack_name="$param"
        fi
        ;;
    esac
    shift
  done

  assert_required_params "$stack_env_name" "$stack_name"
  assert_required_tools

  local machine_id="$(get_manager_machine_id "$stack_env_name" "$stack_name")"

  assert_machine_id "$machine_id" "$stack_env_name"

  local session="octoswarm-$stack_env_name-$stack_name"

  start_server
  has_session "$session" 2> /dev/null
  if [ "$?" != "0" ]; then
    create_session "$session" "$stack_env_name" "$stack_name"
    setup_docker_machine "$session" "$stack_env_name" "$stack_name"
    setup_session "$session" "$machine_id"
    setup_tab_zero "$session"
    setup_tab_shell "$session"
    select_tab "$session" "1" 2> /dev/null
  fi
  attach_session "$session"
}

main "$@"
