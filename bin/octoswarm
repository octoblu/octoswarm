#!/bin/bash

assert_required_tools(){
  if [ "$(which envsubst)" == "" ]; then
    echo "Missing 'envsubst' utility. 'brew install gettext; brew link gettext --force' to install."
    exit 1
  fi
}

assert_required_params(){
  local docker_machine_env="$1"

  if [ -n "$docker_machine_env" -a -n "$stack_name"  ]; then
    return 0
  fi

  usage

  if [ -z "$docker_machine_env" ]; then
    echo "docker_machine_env is missing"
  fi

  if [ -z "$stack_name" ]; then
    echo "stack_name is missing"
  fi

  exit 1
}

get_manager_machine_id(){
  local docker_machine_env="$1"
  local stack_name="$2"

  local dir="$HOME/Projects/Octoblu/swarm-$docker_machine_env/stacks/$stack_name/machine/machines"

  mkdir -p "$dir"
  local random_dir="$(find "$dir" -iname '*manager-*' -maxdepth 1 -mindepth 1 -type d -print0 | gsort --zero-terminated --random-sort | head -1)"
  echo $(basename "$random_dir")
}

script_directory(){
  local source="${BASH_SOURCE[0]}"
  local dir=""

  while [ -h "$source" ]; do # resolve $source until the file is no longer a symlink
    dir="$( cd -P "$( dirname "$source" )" && pwd )"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done

  dir="$( cd -P "$( dirname "$source" )" && pwd )"

  echo "$dir"
}

setup_session() {
  local session="$1"
  local machine_id="$2"
  eval $(docker-machine env --shell=bash "$machine_id")
  tmux set-environment -t $session DOCKER_CERT_PATH $DOCKER_CERT_PATH
  tmux set-environment -t $session DOCKER_TLS_VERIFY $DOCKER_TLS_VERIFY
  tmux set-environment -t $session DOCKER_HOST $DOCKER_HOST
  tmux set-environment -t $session DOCKER_MACHINE_NAME $DOCKER_MACHINE_NAME
  eval $(docker-machine env --unset)
}

select_tab() {
  local session="$1"
  local tab="$2"
  tmux select-window -t "${session}:${tab}"
}

setup_tab_zero() {
  local session="$1"
  tmux send-keys -t "${session}:0.0" C-m || return 1
  tmux send-keys -t "${session}:0.0" "tmux kill-session -t ${session}" || return 1
}

setup_tab_shell() {
  local session="$1"
  tmux new-window -t "${session}:1" -n "shell" || return 1
}

setup_docker_machine() {
  local session="$1"
  local docker_machine_env="$2"
  local stack_name="$3"

  if [ "$docker_machine_env" != "dev" ]; then
    export RAW_MACHINE_STORAGE_PATH="$HOME/Projects/Octoblu/swarm-$docker_machine_env/stacks/$stack_name/machine-template"
    export MACHINE_STORAGE_PATH="$HOME/Projects/Octoblu/swarm-$docker_machine_env/stacks/$stack_name/machine"
    tmux set-environment -t $session MACHINE_STORAGE_PATH "$MACHINE_STORAGE_PATH"
    mkdir -p "$MACHINE_STORAGE_PATH"
    cp -rfp $RAW_MACHINE_STORAGE_PATH/* $MACHINE_STORAGE_PATH
    pushd $MACHINE_STORAGE_PATH
      for file in `find . -iname '*.json'`; do
        cat "$file" | envsubst > "$file.tmp" && mv "$file.tmp" "$file"
      done
      for file in `find . -iname 'id_rsa'`; do
        chmod 600 "$file"
      done
    popd
  fi
}

start_server() {
  tmux start-server
}

attach_session() {
  local session="$1"
  tmux attach-session -t "$session"
}

create_session() {
  local session="$1"
  local docker_machine_env="$2"
  local stack_name="$3"
  export SWARM_ENV_DIR="$HOME/Projects/Octoblu/swarm-$docker_machine_env"
  export STACK_ENV_DIR="$SWARM_ENV_DIR/stacks/$stack_name"
  export STACK_NAME="$docker_machine_env-$stack_name"

  cd "$STACK_ENV_DIR"
  tmux new-session -s "$session" -c "$STACK_ENV_DIR" -n √ø -d
  tmux set-environment -t $session SWARM_ENV_DIR $SWARM_ENV_DIR
  tmux set-environment -t $session STACK_ENV_DIR $STACK_ENV_DIR
  tmux set-environment -t $session STACK_NAME $STACK_NAME
}

has_session() {
  local session="$1"
  tmux has-session -t "$session"
}

fatal() {
  local message="$1"
  echo "Error: $message"
  exit 1
}

script_directory(){
  local source="${BASH_SOURCE[0]}"
  local dir=""

  while [ -h "$source" ]; do # resolve $source until the file is no longer a symlink
    dir="$( cd -P "$( dirname "$source" )" && pwd )"
    source="$(readlink "$source")"
    [[ $source != /* ]] && source="$dir/$source" # if $source was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done

  dir="$( cd -P "$( dirname "$source" )" && pwd )"

  echo "$dir"
}

usage(){
  echo 'USAGE: octomux <docker_machine_env> <stack_name>'
  echo ''
  echo 'Arguments:'
  echo '  -h, --help         print this help text'
  echo '  -v, --version      print the version'
  echo ''
}

version(){
  local directory="$(script_directory)"

  if [ -f "$directory/VERSION" ]; then
    cat "$directory/VERSION"
  else
    echo "unknown"
  fi
}

main() {
  local docker_machine_env
  local stack_name
  while [ "$1" != "" ]; do
    local param="$1"
    local value="$2"
    case "$param" in
      -h | --help)
        usage
        exit 0
        ;;
      -v | --version)
        version
        exit 0
        ;;
      *)
        if [ "${param::1}" == '-' ]; then
          echo "ERROR: unknown parameter \"$param\""
          usage
          exit 1
        fi
        if [ -z "$docker_machine_env" ]; then
          docker_machine_env="$param"
        elif [ -z "$stack_name" ]; then
          stack_name="$param"
        fi
        ;;
    esac
    shift
  done

  assert_required_params "$docker_machine_env" "$stack_name"
  assert_required_tools

  local machine_id="$(get_manager_machine_id "$docker_machine_env" "$stack_name")"
  local session="octoswarm-$docker_machine_env-$stack_name"

  start_server
  has_session "$session"
  if [ "$?" != "0" ]; then
    create_session "$session" "$docker_machine_env" "$stack_name"
    setup_docker_machine "$session" "$docker_machine_env" "$stack_name"
    setup_session "$session" "$machine_id"
    setup_tab_zero "$session"
    setup_tab_shell "$session"
    select_tab "$session" "1" 2> /dev/null
  fi
  attach_session "$session"
}

main "$@"
